{% extends "base.html" %}

{% block head %}
{{ super() }}
<!-- Update Chart.js import to use a complete CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
.kpi-card {
    border-radius: 8px;
    padding: 12px;  /* Further reduced padding */
    margin-bottom: 12px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    background-color: white;
    transition: all 0.3s ease;
    min-height: 140px;  /* Reduced minimum height */
    display: flex;
    flex-direction: column;
    position: relative;
}

.kpi-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.kpi-title {
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 15px;
}

.kpi-value {
    font-size: 1.6rem;  /* Slightly smaller font */
    font-weight: bold;
    margin: 4px 0;  /* Reduced margin */
    line-height: 1.2;  /* Tighter line height */
}

.kpi-comparison {
    font-size: 0.75rem;  /* Smaller font */
    color: #666;
    margin-bottom: 8px;  /* Reduced margin */
    line-height: 1.2;  /* Tighter line height */
}

.positive-change {
    color: #28a745;
}

.negative-change {
    color: #dc3545;
}

.loading-placeholder {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
}

@keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

/* Drag and drop styles */
.customize-mode .kpi-card {
    cursor: grab;
    animation: jiggle 0.3s infinite;
    user-select: none;
}

.customize-mode .kpi-card.dragging {
    cursor: grabbing;
    animation: none;
    opacity: 0.8;
    transform: scale(1.05);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
}

.kpi-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));  /* Slightly smaller cards */
    gap: 12px;  /* Reduced gap */
    padding: 12px;
}

@keyframes jiggle {
    0% { transform: rotate(0deg); }
    25% { transform: rotate(0.5deg); }
    75% { transform: rotate(-0.5deg); }
    100% { transform: rotate(0deg); }
}

/* Customize button */
.customize-btn {
    position: relative;
}

.customize-btn.active {
    background-color: #0d6efd;
    color: white;
}

.customize-btn .customize-hint {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.8rem;
    white-space: nowrap;
    margin-bottom: 5px;
}

.customize-btn:hover .customize-hint {
    display: block;
}

.kpi-placeholder {
    border: 2px dashed #ccc;
    background-color: rgba(200, 200, 200, 0.3);
    opacity: 0.6;
    pointer-events: none;
}

.customize-mode .kpi-card {
    transition: transform 0.2s ease;
}

.customize-mode .kpi-card.dragging {
    z-index: 1000;
    cursor: grabbing;
}

/* Add smooth transitions */
.kpi-card {
    transition: all 0.3s ease;
}

.kpi-card {
    margin: 0;  /* Remove margin since we're using grid gap */
    height: 100%;  /* Ensure consistent height */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transition: all 0.2s ease-out;
}

.customize-mode .kpi-card {
    cursor: grab;
    animation: jiggle 0.3s infinite;
    transform-origin: center center;
}

.kpi-card.dragging {
    animation: none;
    cursor: grabbing;
    transform: scale(1.05);
    box-shadow: 0 12px 24px rgba(0,0,0,0.2);
}

.kpi-placeholder {
    border: 2px dashed #ccc;
    background-color: rgba(200, 200, 200, 0.2);
    border-radius: 8px;
    height: 100%;
    opacity: 0.6;
    pointer-events: none;
    transition: all 0.2s ease-out;
}

/* Update the dragging styles */
.kpi-card.dragging {
    animation: none !important;
    cursor: grabbing !important;
    box-shadow: 0 12px 24px rgba(0,0,0,0.2) !important;
    background: white !important;
    pointer-events: none !important;
    transition: none !important;
}

.customize-mode .kpi-card {
    cursor: grab;
    animation: jiggle 0.3s infinite;
    user-select: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.kpi-placeholder {
    border: 2px dashed #ccc;
    background-color: rgba(200, 200, 200, 0.2);
    border-radius: 8px;
    opacity: 0.6;
    pointer-events: none;
    transition: all 0.2s ease;
}

.ghost-card {
    visibility: hidden;
    position: absolute;
    pointer-events: none;
}

/* Card controls in customize mode */
.kpi-card .card-controls {
    display: none;
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 4px;
    padding: 3px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 10;
}

.customize-mode .kpi-card .card-controls {
    display: flex;
    gap: 4px;
}

.card-control-btn {
    width: 20px;  /* Smaller buttons */
    height: 20px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    font-size: 10px;
    color: #666;
    transition: all 0.2s ease;
}

.card-control-btn:hover {
    background: #f0f0f0;
    color: #333;
}

/* Separator button styles */
.separator-btn {
    width: 100%;
    height: 100%;  /* Match card height */
    min-height: 140px;  /* Match card height */
    background: transparent;
    border: 2px dashed #ccc;
    border-radius: 8px;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #666;
    font-size: 12px;
    transition: all 0.2s ease;
    margin: 0;  /* Remove margin to match grid spacing */
}

.customize-mode .separator-btn {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.separator-btn i {
    font-size: 20px;
    margin-bottom: 6px;
}

.separator-btn:hover {
    border-color: #0d6efd;
    color: #0d6efd;
    background: rgba(13, 110, 253, 0.05);
}

/* Space placeholder styles */
.space-placeholder {
    width: 100%;
    height: 100%;  /* Match card height */
    min-height: 140px;  /* Match card height */
    background: #f8f9fa;
    border-radius: 8px;
    margin: 0;  /* Remove margin to match grid spacing */
    transition: all 0.2s ease;
}

/* Position the cards relatively for absolute positioning of controls */
.kpi-card {
    position: relative;
}

/* KPI Card Header */
.kpi-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;  /* Reduced margin */
}

.kpi-name {
    font-size: 0.8rem;  /* Smaller font */
    font-weight: 600;
    color: #495057;
}

.time-span-badge {
    font-size: 0.7rem;  /* Smaller font */
    padding: 0.15rem 0.4rem;
    background-color: #e9ecef;
    border-radius: 4px;
    color: #6c757d;
}

/* Updated condition badges */
.condition-badges {
    margin-top: 8px;  /* Reduced margin */
    display: flex;
    flex-wrap: wrap;
    gap: 4px;  /* Smaller gap */
    padding-top: 8px;
    border-top: 1px solid #eee;
}

.condition-badge {
    font-size: 0.65rem;  /* Smaller font */
    padding: 0.1rem 0.35rem;  /* Reduced padding */
    border-radius: 10px;
    color: white;
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-weight: 500;
    line-height: 1.2;  /* Tighter line height */
}

.condition-badge i {
    font-size: 0.6rem;  /* Smaller icon */
}

/* Condition badge colors based on operator */
.condition-badge[data-operator="="] {
    background-color: #0d6efd;  /* Bootstrap primary */
}

.condition-badge[data-operator="!="] {
    background-color: #dc3545;  /* Bootstrap danger */
}

.condition-badge[data-operator=">"] {
    background-color: #198754;  /* Bootstrap success */
}

.condition-badge[data-operator=">="] {
    background-color: #20c997;  /* Bootstrap info */
}

.condition-badge[data-operator="<"] {
    background-color: #fd7e14;  /* Bootstrap warning */
}

.condition-badge[data-operator="<="] {
    background-color: #ffc107;  /* Bootstrap warning */
}

/* Add styles for charts section */
.charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));  /* Increased minimum width */
    gap: 20px;
    margin-top: 20px;
}

.chart-container {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    height: 400px;  /* Fixed container height */
    display: flex;
    flex-direction: column;
}

.chart-header {
    flex: 0 0 auto;  /* Header won't grow/shrink */
}

.chart-badges {
    flex: 0 0 auto;  /* Badges won't grow/shrink */
}

.chart-wrapper {
    flex: 1;         /* Take all remaining space */
    position: relative;
    min-height: 0;   /* Allow container to shrink */
}

.chart-container canvas {
    position: absolute !important;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
}

.chart-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #333;
}

/* Add styles for chart canvas */
.chart-container canvas {
    width: 100% !important;
    height: calc(100% - 50px) !important;  /* Subtract header height */
}

/* Chart badges styles */
.chart-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid #eee;
}

.chart-container .time-span-badge {
    font-size: 0.7rem;
    padding: 0.15rem 0.4rem;
    background-color: #e9ecef;
    border-radius: 4px;
    color: #6c757d;
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
}

.chart-container .condition-badge {
    font-size: 0.65rem;
    padding: 0.1rem 0.35rem;
    border-radius: 10px;
    color: white;
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-weight: 500;
}

.chart-container .condition-badge i {
    font-size: 0.6rem;
}

/* Update chart container height to accommodate badges */
.chart-container {
    height: 450px;  /* Increased height to accommodate badges */
}

.chart-container canvas {
    height: calc(100% - 80px) !important;  /* Adjust for header and badges */
}

/* Add these to your existing styles */
.customize-mode .chart-container {
    cursor: grab;
    animation: jiggle 0.3s infinite;
    user-select: none;
}

.customize-mode .chart-container .card-controls {
    display: flex;
}

.space-placeholder {
    background: #f8f9fa;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    min-height: 140px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #6c757d;
    position: relative;
}

.space-placeholder .card-controls {
    position: absolute;
    top: 8px;
    right: 8px;
}

.separator-btn {
    width: 100%;
    height: 100%;
    background: transparent;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #6c757d;
    transition: all 0.2s ease;
}

.customize-mode .separator-btn {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.separator-btn:hover {
    border-color: #0d6efd;
    color: #0d6efd;
    background: rgba(13, 110, 253, 0.05);
}

.customize-mode .chart-container,
.customize-mode .kpi-card,
.customize-mode .space-placeholder {
    transition: transform 0.2s ease;
}

.customize-mode .chart-container.dragging,
.customize-mode .kpi-card.dragging,
.customize-mode .space-placeholder.dragging {
    z-index: 1000;
    cursor: grabbing;
}

/* Add these to your existing styles */
.space-placeholder {
    background: #f8f9fa;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #6c757d;
    position: relative;
}

.space-placeholder.kpi-spacer {
    min-height: 140px;  /* Match KPI card height */
}

.space-placeholder.chart-spacer {
    min-height: 400px;  /* Match chart container height */
}

.separator-btn {
    width: 100%;
    background: transparent;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #6c757d;
    transition: all 0.2s ease;
    margin: 0;
}

.separator-btn.kpi-spacer {
    height: 140px;  /* Match KPI card height */
}

.separator-btn.chart-spacer {
    height: 400px;  /* Match chart container height */
}

.customize-mode .separator-btn {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.separator-btn:hover {
    border-color: #0d6efd;
    color: #0d6efd;
    background: rgba(13, 110, 253, 0.05);
}

/* Add these functions after the existing ones */
function initializeResizing() {
    const gridSize = 20; // Size of grid cells for snapping
    const minWidth = 250; // Minimum width for KPI cards
    const minHeight = 140; // Minimum height for KPI cards
    const minChartWidth = 500; // Minimum width for chart cards
    const minChartHeight = 300; // Minimum height for chart cards

    function makeResizable(element) {
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        element.appendChild(resizeHandle);

        let isResizing = false;
        let originalWidth;
        let originalHeight;
        let originalX;
        let originalY;
        let currentSpacers = [];

        resizeHandle.addEventListener('mousedown', initResize);

        function initResize(e) {
            if (!isCustomizing) return;
            
            isResizing = true;
            originalWidth = element.offsetWidth;
            originalHeight = element.offsetHeight;
            originalX = e.clientX;
            originalY = e.clientY;

            // Store initial positions of spacers
            currentSpacers = Array.from(document.querySelectorAll('.space-placeholder'));
            currentSpacers.forEach(spacer => {
                spacer.dataset.originalTop = spacer.getBoundingClientRect().top;
                spacer.dataset.originalLeft = spacer.getBoundingClientRect().left;
            });

            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
            
            // Add resizing class for visual feedback
            element.classList.add('resizing');
            
            // Add overlay to prevent mouse events on other elements
            addResizeOverlay();
        }

        function resize(e) {
            if (!isResizing) return;

            // Calculate new dimensions
            const width = originalWidth + (e.clientX - originalX);
            const height = originalHeight + (e.clientY - originalY);

            // Snap to grid
            const snappedWidth = Math.round(width / gridSize) * gridSize;
            const snappedHeight = Math.round(height / gridSize) * gridSize;

            // Apply minimum dimensions based on card type
            const isChart = element.classList.contains('chart-container');
            const minW = isChart ? minChartWidth : minWidth;
            const minH = isChart ? minChartHeight : minHeight;

            // Calculate grid columns based on container width
            const container = element.parentElement;
            const containerWidth = container.offsetWidth;
            const maxColumns = Math.floor(containerWidth / gridSize);

            // Ensure width snaps to grid columns
            const columnWidth = containerWidth / maxColumns;
            const columns = Math.round(snappedWidth / columnWidth);
            const gridSnappedWidth = Math.max(minW, Math.min(columns * columnWidth, containerWidth));

            // Apply new dimensions
            if (gridSnappedWidth >= minW) {
                element.style.width = `${gridSnappedWidth}px`;
            }
            if (snappedHeight >= minH) {
                element.style.height = `${snappedHeight}px`;
            }

            // Update spacer positions
            updateSpacerPositions(element, gridSnappedWidth, snappedHeight);

            // Re-render content based on card type
            if (isChart) {
                const chartId = element.querySelector('canvas').id;
                const chartInstance = Chart.getChart(chartId);
                if (chartInstance) {
                    chartInstance.resize();
                }
            }
        }

        function stopResize() {
            if (!isResizing) return;
            
            isResizing = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
            element.classList.remove('resizing');
            
            // Remove overlay
            removeResizeOverlay();
            
            // Save the layout
            saveLayout();
        }

        function updateSpacerPositions(resizingElement, newWidth, newHeight) {
            const elementRect = resizingElement.getBoundingClientRect();
            
            currentSpacers.forEach(spacer => {
                const spacerOriginalTop = parseFloat(spacer.dataset.originalTop);
                const spacerOriginalLeft = parseFloat(spacer.dataset.originalLeft);
                
                // Check if spacer needs to move
                if (spacerOriginalTop >= elementRect.bottom || 
                    spacerOriginalLeft >= elementRect.right) {
                    
                    // Calculate new position
                    let newTop = spacerOriginalTop;
                    let newLeft = spacerOriginalLeft;
                    
                    if (spacerOriginalTop === elementRect.top) {
                        newLeft = Math.max(spacerOriginalLeft, elementRect.right + gridSize);
                    }
                    if (spacerOriginalLeft === elementRect.left) {
                        newTop = Math.max(spacerOriginalTop, elementRect.bottom + gridSize);
                    }
                    
                    // Apply new position with smooth transition
                    spacer.style.transform = `translate(${newLeft - spacerOriginalLeft}px, ${newTop - spacerOriginalTop}px)`;
                }
            });
        }
    }

    // Apply resizing to all cards
    document.querySelectorAll('.kpi-card, .chart-container').forEach(makeResizable);
}

// Helper functions for resize overlay
function addResizeOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'resize-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        cursor: se-resize;
    `;
    document.body.appendChild(overlay);
}

function removeResizeOverlay() {
    const overlay = document.querySelector('.resize-overlay');
    if (overlay) {
        overlay.remove();
    }
}

/* Add to your existing styles */
.resize-handle {
    position: absolute;
    right: 0;
    bottom: 0;
    width: 20px;
    height: 20px;
    cursor: se-resize;
    background: linear-gradient(135deg, transparent 50%, #0d6efd 50%);
    border-radius: 0 0 8px 0;
    opacity: 0;
    transition: opacity 0.2s;
}

.customize-mode .resize-handle {
    opacity: 0.7;
}

.customize-mode .resize-handle:hover {
    opacity: 1;
}

.space-placeholder {
    transition: transform 0.3s ease;
}

.resizing {
    z-index: 1000;
    pointer-events: none;
}

.resize-overlay {
    background: transparent;
}

/* Update grid containers to use CSS Grid */
.kpi-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    padding: 20px;
    align-items: start;
}

.charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
    gap: 20px;
    padding: 20px;
    align-items: start;
}

/* Add snapping guidelines */
.snap-guide {
    position: absolute;
    background: rgba(13, 110, 253, 0.3);
    pointer-events: none;
    z-index: 1001;
}

.snap-guide.vertical {
    width: 1px;
    height: 100%;
}

.snap-guide.horizontal {
    height: 1px;
    width: 100%;
}

/* Update resize handle styles */
.kpi-card, .chart-container {
    position: relative;
    resize: both;  /* Enable native resizing */
    overflow: hidden;  /* Required for resize to work */
}

.resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    bottom: 0;
    right: 0;
    cursor: se-resize;
    display: none;
    z-index: 10;
}

.resize-handle::before {
    content: '';
    position: absolute;
    right: 3px;
    bottom: 3px;
    width: 9px;
    height: 9px;
    border-right: 2px solid #0d6efd;
    border-bottom: 2px solid #0d6efd;
}

.customize-mode .resize-handle {
    display: block;
}

/* Add resize cursors to all edges */
.customize-mode .kpi-card::after,
.customize-mode .chart-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
}

.customize-mode .kpi-card:hover::after,
.customize-mode .chart-container:hover::after {
    border: 1px solid #0d6efd;
}

/* Edge resize cursors */
.customize-mode .kpi-card .edge-n,
.customize-mode .chart-container .edge-n {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 5px;
    cursor: n-resize;
}

.customize-mode .kpi-card .edge-e,
.customize-mode .chart-container .edge-e {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    width: 5px;
    cursor: e-resize;
}

.customize-mode .kpi-card .edge-s,
.customize-mode .chart-container .edge-s {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 5px;
    cursor: s-resize;
}

.customize-mode .kpi-card .edge-w,
.customize-mode .chart-container .edge-w {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 5px;
    cursor: w-resize;
}

// Add these styles to your existing styles
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h2>Statistics</h2>
    <div class="btn-group">
        <button id="customize-btn" class="btn btn-light customize-btn" onclick="toggleCustomizeMode()">
            <i class="fas fa-grip-vertical"></i> Customize Layout
            <span class="customize-hint">Click to rearrange KPI cards</span>
        </button>
        <a href="{{ url_for('stats_config') }}" class="btn btn-light">
            <i class="fas fa-cog"></i> Configure KPIs
        </a>
        <a href="{{ url_for('charts_config') }}" class="btn btn-light">
            <i class="fas fa-chart-line"></i> Configure Charts
        </a>
    </div>
</div>

<!-- KPIs Section -->
<h3 class="mb-3">Key Performance Indicators</h3>
<div id="kpis-container" class="kpi-grid">
    <!-- KPI cards will be loaded here -->
</div>

<!-- Charts Section -->
<h3 class="mt-5 mb-3">Charts</h3>
<div id="charts-container" class="charts-grid">
    <!-- Charts will be loaded here -->
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
// First, define all helper functions
function getTimeSpanAbbreviation(timeSpan) {
    const abbreviations = {
        'Today': 'TDY',
        'Yesterday': 'YDY',
        'Month to Date': 'MTD',
        'Last Month to Date': 'LMTD',
        'Year to Date': 'YTD',
        'Last Year to Date': 'LYTD'
    };
    return abbreviations[timeSpan] || timeSpan;
}

function getOperatorSymbol(operator) {
    const symbols = {
        '=': '=',
        '!=': '≠',
        '>': '>',
        '>=': '≥',
        '<': '<',
        '<=': '≤'
    };
    return symbols[operator] || operator;
}

// Add customize layout functionality
let isCustomizing = false;
let draggedCard = null;

function toggleCustomizeMode() {
    isCustomizing = !isCustomizing;
    const kpiContainer = document.getElementById('kpis-container');
    const chartContainer = document.getElementById('charts-container');
    const btn = document.getElementById('customize-btn');
    
    if (isCustomizing) {
        kpiContainer.classList.add('customize-mode');
        chartContainer.classList.add('customize-mode');
        btn.classList.add('active');
        
        // Show all card controls
        $('.card-controls').show();
        $('.resize-handle').show();
        
        // Add spacer buttons to both containers
        addSpacerButton(kpiContainer, 'kpi-spacer');
        addSpacerButton(chartContainer, 'chart-spacer');
    } else {
        kpiContainer.classList.remove('customize-mode');
        chartContainer.classList.remove('customize-mode');
        btn.classList.remove('active');
        
        // Hide all card controls
        $('.card-controls').hide();
        $('.resize-handle').hide();
        
        // Remove spacer buttons
        $('.separator-btn').remove();
        
        // Save the current layout
        saveLayout();
    }
}

// Update the spacer button functions
function addSpacerButton(container, type) {
    const spacerBtn = document.createElement('button');
    spacerBtn.className = 'separator-btn';
    spacerBtn.innerHTML = `
        <i class="fas fa-plus"></i>
        <span>Add Space</span>
    `;
    spacerBtn.onclick = () => addSpacer(container, type);
    container.appendChild(spacerBtn);
}

function addSpacer(container, type) {
    const spacer = document.createElement('div');
    spacer.className = `space-placeholder ${type}`;
    spacer.draggable = true;
    spacer.innerHTML = `
        <div class="card-controls">
            <button class="card-control-btn move-up" title="Move Up">
                <i class="fas fa-chevron-up"></i>
            </button>
            <button class="card-control-btn move-down" title="Move Down">
                <i class="fas fa-chevron-down"></i>
            </button>
            <button class="card-control-btn move-left" title="Move Left">
                <i class="fas fa-chevron-left"></i>
            </button>
            <button class="card-control-btn move-right" title="Move Right">
                <i class="fas fa-chevron-right"></i>
            </button>
            <button class="card-control-btn remove-space" title="Remove Space">
                <i class="fas fa-times"></i>
            </button>
        </div>
    `;
    
    // Insert before the separator button
    const separatorBtn = container.querySelector('.separator-btn');
    container.insertBefore(spacer, separatorBtn);
    
    // Add remove functionality
    spacer.querySelector('.remove-space').onclick = () => spacer.remove();
}

// Update the control button handler to include spacers
document.addEventListener('click', function(e) {
    if (!isCustomizing) return;
    
    const btn = e.target.closest('.card-control-btn');
    if (!btn) return;
    
    const card = btn.closest('.kpi-card, .chart-container, .space-placeholder');
    if (!card) return;
    
    const container = card.parentElement;
    const cards = Array.from(container.children).filter(child => 
        child.classList.contains('kpi-card') || 
        child.classList.contains('chart-container') || 
        child.classList.contains('space-placeholder')
    );
    const currentIndex = cards.indexOf(card);
    
    const gridColumns = Math.floor(container.offsetWidth / card.offsetWidth);
    
    if (btn.classList.contains('remove-space') && card.classList.contains('space-placeholder')) {
        card.remove();
        return;
    }
    
    if (btn.classList.contains('move-up')) {
        if (currentIndex >= gridColumns) {
            container.insertBefore(card, cards[currentIndex - gridColumns]);
        }
    } else if (btn.classList.contains('move-down')) {
        if (currentIndex + gridColumns < cards.length) {
            const targetIndex = currentIndex + gridColumns;
            const targetCard = cards[targetIndex];
            if (targetCard) {
                targetCard.parentNode.insertBefore(card, targetCard.nextSibling);
            } else {
                container.appendChild(card);
            }
        }
    } else if (btn.classList.contains('move-left')) {
        if (currentIndex % gridColumns > 0) {
            container.insertBefore(card, cards[currentIndex - 1]);
        }
    } else if (btn.classList.contains('move-right')) {
        if (currentIndex % gridColumns < gridColumns - 1 && currentIndex < cards.length - 1) {
            container.insertBefore(card, cards[currentIndex + 2]);
        }
    }
});

// Add these helper functions at the top level
function createTimeSpanBadges(timeSpans) {
    if (!timeSpans || !timeSpans.length) return '';
    return timeSpans.map(span => `
        <span class="time-span-badge">
            ${getTimeSpanAbbreviation(span[0])} vs ${getTimeSpanAbbreviation(span[1])}
        </span>
    `).join('');
}

function createConditionBadges(yAxis) {
    if (!yAxis || !yAxis.length) return '';
    return yAxis.map(measure => {
        if (!measure.conditions || !measure.conditions.length) return '';
        return measure.conditions.map(condition => `
            <div class="condition-badge" data-operator="${condition.operator}">
                <i class="fas fa-filter"></i>
                ${condition.field} ${getOperatorSymbol(condition.operator)} ${condition.value}
            </div>
        `).join('');
    }).join('');
}

// Update the createChartDiv function
function createChartDiv(chart) {
    try {
        // Parse time spans and y-axis data
        const timeSpans = typeof chart.time_spans === 'string' ? 
                         JSON.parse(chart.time_spans) : chart.time_spans;
        const yAxis = typeof chart.y_axis === 'string' ? 
                     JSON.parse(chart.y_axis) : chart.y_axis;
        
        console.log('Parsed data:', { timeSpans, yAxis });
        
        const chartDiv = $(`
            <div class="chart-container">
                <div class="chart-header">
                    <div>
                        <span class="chart-title">${chart.name}</span>
                        <div class="chart-badges">
                            ${createTimeSpanBadges(timeSpans)}
                            ${createConditionBadges(yAxis)}
                        </div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="chart-${chart.id}"></canvas>
                </div>
            </div>
        `);
        
        return chartDiv;
    } catch (error) {
        console.error('Error creating chart div:', error, chart);
        return $('<div class="alert alert-danger">Error creating chart</div>');
    }
}

// Update the loadCharts function
function loadCharts() {
    console.log('Loading charts...');
    $.get('/api/charts/data', function(charts) {
        console.log('Received charts data:', charts);
        const container = $('#charts-container');
        container.empty();
        
        if (charts && charts.length > 0) {
            charts.forEach(chart => {
                try {
                    console.log('Processing chart:', chart);
                    if (chart.is_enabled) {
                        const chartDiv = createChartDiv(chart);
                        container.append(chartDiv);
                        
                        // Wait for the DOM to update before rendering the chart
                        setTimeout(() => {
                            renderChart(chart, `chart-${chart.id}`);
                        }, 0);
                    }
                } catch (error) {
                    console.error('Error processing chart:', error, chart);
                }
            });
        } else {
            console.log('No charts found or charts array is empty');
            container.html(`
                <div class="alert alert-info">
                    No charts configured. <a href="${window.location.origin}/stats/charts">Configure charts</a>
                </div>
            `);
        }
    }).fail(function(error) {
        console.error('Error loading charts:', error);
        $('#charts-container').html(`
            <div class="alert alert-danger">
                Error loading charts. Please try again later.
            </div>
        `);
    });
}

function renderChart(chartData, canvasId) {
    console.log('Rendering chart to canvas:', canvasId);
    console.log('Chart data:', chartData);
    
    const ctx = document.getElementById(canvasId).getContext('2d');
    if (!ctx) {
        console.error('Could not get canvas context for:', canvasId);
        return;
    }
    
    // Create Chart.js configuration based on chart type and data
    const config = {
        type: chartData.chart_type,
        data: {
            labels: chartData.labels,
            datasets: chartData.datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: 12,
                        padding: 8,
                        font: {
                            weight: 'bold'  // Make legend labels bold
                        }
                    }
                },
                title: {
                    display: false
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        padding: 8,
                        font: {
                            weight: 'bold'  // Make Y-axis labels bold
                        }
                    }
                },
                x: {
                    ticks: {
                        padding: 8,
                        font: {
                            weight: 'bold'  // Make X-axis labels bold
                        }
                    }
                }
            },
            layout: {
                padding: {
                    top: 10,
                    right: 10,
                    bottom: 10,
                    left: 10
                }
            }
        }
    };
    
    console.log('Chart configuration:', config);
    try {
        new Chart(ctx, config);
        console.log('Chart rendered successfully');
    } catch (error) {
        console.error('Error rendering chart:', error);
    }
}

// Add drag and drop functionality
function initializeDragAndDrop() {
    const container = document.getElementById('kpis-container');
    
    container.addEventListener('dragstart', (e) => {
        if (!isCustomizing) return;
        draggedCard = e.target;
        e.target.classList.add('dragging');
    });
    
    container.addEventListener('dragend', (e) => {
        if (!isCustomizing) return;
        e.target.classList.remove('dragging');
    });
    
    container.addEventListener('dragover', (e) => {
        if (!isCustomizing) return;
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        const card = draggedCard;
        if (afterElement == null) {
            container.appendChild(card);
        } else {
            container.insertBefore(card, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.kpi-card:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Define the main functions
function loadKPIs() {
    console.log('Loading KPIs...');
    $.get('/calculate_kpis', function(data) {
        console.log('Received KPI data:', data);
        const container = $('#kpis-container');
        container.empty();
        
        if (data && data.length > 0) {
            data.forEach((kpi, index) => {
                appendKPICard(container, kpi, index);
            });
        } else {
            container.html(`
                <div class="col-12 text-center">
                    <p class="text-muted">No KPIs configured. 
                        <a href="${window.location.origin}/stats/config">Configure KPIs</a>
                    </p>
                </div>
            `);
        }
    }).fail(function(error) {
        console.error('Error loading KPIs:', error);
        $('#kpis-container').html(`
            <div class="alert alert-danger">
                Error loading KPIs. Please try again later.
            </div>
        `);
    });
}

function appendKPICard(container, kpi, index) {
    console.log('Appending KPI card:', kpi);
    const changeClass = kpi.change >= 0 ? 'positive-change' : 'negative-change';
    const changeIcon = kpi.change >= 0 ? '↑' : '↓';
    const changeText = Math.abs(kpi.change) + '%';
    
    // Extract the base KPI name and time span from the full name
    const nameMatch = kpi.name.match(/(.*?)\s*\((.*?)\)$/);
    const baseName = nameMatch ? nameMatch[1] : kpi.name;
    const timeSpan = nameMatch ? nameMatch[2] : '';
    const timeSpanAbbr = getTimeSpanAbbreviation(timeSpan);
    
    // Get conditions from the KPI data
    let conditions = [];
    try {
        // Get conditions from the KPI configuration
        const baseKpiId = baseName.toLowerCase();
        $.ajax({
            url: '/get_kpi_config_by_name/' + encodeURIComponent(baseKpiId),
            method: 'GET',
            async: false,
            success: function(data) {
                console.log('Got KPI config for', baseKpiId, ':', data);
                if (data.conditions) {
                    conditions = typeof data.conditions === 'string' ? 
                                JSON.parse(data.conditions) : data.conditions;
                }
            }
        });
    } catch (e) {
        console.error('Error getting conditions:', e);
        conditions = [];
    }
    
    // Create badges for each condition
    const conditionBadges = Array.isArray(conditions) ? conditions.map(condition => {
        return `
            <div class="condition-badge" data-operator="${condition.operator}">
                <i class="fas fa-filter"></i>
                ${condition.field} ${getOperatorSymbol(condition.operator)} ${condition.value}
            </div>
        `;
    }).join('') : '';
    
    const kpiHtml = `
        <div class="kpi-card" data-kpi-id="${index}">
            <div class="card-controls">
                <button class="card-control-btn move-up" title="Move Up">
                    <i class="fas fa-chevron-up"></i>
                </button>
                <button class="card-control-btn move-down" title="Move Down">
                    <i class="fas fa-chevron-down"></i>
                </button>
                <button class="card-control-btn move-left" title="Move Left">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <button class="card-control-btn move-right" title="Move Right">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="kpi-card-header">
                <span class="kpi-name">${baseName}</span>
                <span class="time-span-badge">${timeSpanAbbr}</span>
            </div>
            <div class="kpi-value">${kpi.current_value}</div>
            <div class="kpi-comparison">
                <span class="${changeClass}">
                    ${changeIcon} ${changeText}
                </span>
                vs ${getTimeSpanAbbreviation(kpi.comparison_period)}
            </div>
            ${conditions.length > 0 ? `
                <div class="condition-badges">
                    ${conditionBadges}
                </div>
            ` : ''}
        </div>
    `;
    
    container.append(kpiHtml);
}

// Add these functions to handle layout saving
function saveLayout() {
    const layout = {
        kpis: [],
        charts: []
    };
    
    // Save KPI layouts
    $('#kpis-container .kpi-card').each(function() {
        const kpi = {
            id: $(this).data('kpi-id'),
            width: $(this).width(),
            height: $(this).height(),
            position: $(this).index()
        };
        layout.kpis.push(kpi);
    });
    
    // Save chart layouts
    $('#charts-container .chart-container').each(function() {
        const chart = {
            id: $(this).find('canvas').attr('id').split('-')[1],
            width: $(this).width(),
            height: $(this).height(),
            position: $(this).index()
        };
        layout.charts.push(chart);
    });
    
    // Save to localStorage
    localStorage.setItem('dashboardLayout', JSON.stringify(layout));
    
    // Also save to server
    $.ajax({
        url: '/api/save_layout',
        method: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(layout),
        success: function(response) {
            console.log('Layout saved successfully');
        },
        error: function(error) {
            console.error('Error saving layout:', error);
        }
    });
}

function loadLayout() {
    // Try to load from localStorage first
    const savedLayout = localStorage.getItem('dashboardLayout');
    if (savedLayout) {
        applyLayout(JSON.parse(savedLayout));
    }
    
    // Also load from server (will override localStorage if exists)
    $.get('/api/get_layout', function(layout) {
        if (layout) {
            applyLayout(layout);
            // Update localStorage with server data
            localStorage.setItem('dashboardLayout', JSON.stringify(layout));
        }
    });
}

function applyLayout(layout) {
    // Apply KPI layouts
    layout.kpis.forEach(kpi => {
        const card = $(`.kpi-card[data-kpi-id="${kpi.id}"]`);
        if (card.length) {
            card.width(kpi.width);
            card.height(kpi.height);
            // Move to correct position
            const container = $('#kpis-container');
            if (kpi.position !== card.index()) {
                if (kpi.position === 0) {
                    container.prepend(card);
                } else {
                    const cards = container.children();
                    if (kpi.position >= cards.length) {
                        container.append(card);
                    } else {
                        $(cards[kpi.position]).before(card);
                    }
                }
            }
        }
    });
    
    // Apply chart layouts
    layout.charts.forEach(chart => {
        const container = $(`#chart-${chart.id}`).closest('.chart-container');
        if (container.length) {
            container.width(chart.width);
            container.height(chart.height);
            // Move to correct position
            const chartsContainer = $('#charts-container');
            if (chart.position !== container.index()) {
                if (chart.position === 0) {
                    chartsContainer.prepend(container);
                } else {
                    const containers = chartsContainer.children();
                    if (chart.position >= containers.length) {
                        chartsContainer.append(container);
                    } else {
                        $(containers[chart.position]).before(container);
                    }
                }
            }
            // Re-render chart to fit new size
            const chartInstance = Chart.getChart(`chart-${chart.id}`);
            if (chartInstance) {
                chartInstance.resize();
            }
        }
    });
}

// Add the initialization function
function initializeResizing() {
    const gridSize = 20; // Size of grid cells for snapping
    const minWidth = 250; // Minimum width for KPI cards
    const minHeight = 140; // Minimum height for KPI cards
    const minChartWidth = 500; // Minimum width for chart cards
    const minChartHeight = 300; // Minimum height for chart cards

    function makeResizable(element) {
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        element.appendChild(resizeHandle);

        let isResizing = false;
        let originalWidth;
        let originalHeight;
        let originalX;
        let originalY;
        let currentSpacers = [];

        resizeHandle.addEventListener('mousedown', initResize);

        function initResize(e) {
            if (!isCustomizing) return;
            
            isResizing = true;
            originalWidth = element.offsetWidth;
            originalHeight = element.offsetHeight;
            originalX = e.clientX;
            originalY = e.clientY;

            // Store initial positions of spacers
            currentSpacers = Array.from(document.querySelectorAll('.space-placeholder'));
            currentSpacers.forEach(spacer => {
                spacer.dataset.originalTop = spacer.getBoundingClientRect().top;
                spacer.dataset.originalLeft = spacer.getBoundingClientRect().left;
            });

            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
            
            // Add resizing class for visual feedback
            element.classList.add('resizing');
            
            // Add overlay to prevent mouse events on other elements
            addResizeOverlay();
        }

        function resize(e) {
            if (!isResizing) return;

            // Calculate new dimensions
            const width = originalWidth + (e.clientX - originalX);
            const height = originalHeight + (e.clientY - originalY);

            // Snap to grid
            const snappedWidth = Math.round(width / gridSize) * gridSize;
            const snappedHeight = Math.round(height / gridSize) * gridSize;

            // Apply minimum dimensions based on card type
            const isChart = element.classList.contains('chart-container');
            const minW = isChart ? minChartWidth : minWidth;
            const minH = isChart ? minChartHeight : minHeight;

            // Calculate grid columns based on container width
            const container = element.parentElement;
            const containerWidth = container.offsetWidth;
            const maxColumns = Math.floor(containerWidth / gridSize);

            // Ensure width snaps to grid columns
            const columnWidth = containerWidth / maxColumns;
            const columns = Math.round(snappedWidth / columnWidth);
            const gridSnappedWidth = Math.max(minW, Math.min(columns * columnWidth, containerWidth));

            // Apply new dimensions
            if (gridSnappedWidth >= minW) {
                element.style.width = `${gridSnappedWidth}px`;
            }
            if (snappedHeight >= minH) {
                element.style.height = `${snappedHeight}px`;
            }

            // Update spacer positions
            updateSpacerPositions(element, gridSnappedWidth, snappedHeight);

            // Re-render content based on card type
            if (isChart) {
                const chartId = element.querySelector('canvas').id;
                const chartInstance = Chart.getChart(chartId);
                if (chartInstance) {
                    chartInstance.resize();
                }
            }
        }

        function stopResize() {
            if (!isResizing) return;
            
            isResizing = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
            element.classList.remove('resizing');
            
            // Remove overlay
            removeResizeOverlay();
            
            // Save the layout
            saveLayout();
        }

        function updateSpacerPositions(resizingElement, newWidth, newHeight) {
            const elementRect = resizingElement.getBoundingClientRect();
            
            currentSpacers.forEach(spacer => {
                const spacerOriginalTop = parseFloat(spacer.dataset.originalTop);
                const spacerOriginalLeft = parseFloat(spacer.dataset.originalLeft);
                
                // Check if spacer needs to move
                if (spacerOriginalTop >= elementRect.bottom || 
                    spacerOriginalLeft >= elementRect.right) {
                    
                    // Calculate new position
                    let newTop = spacerOriginalTop;
                    let newLeft = spacerOriginalLeft;
                    
                    if (spacerOriginalTop === elementRect.top) {
                        newLeft = Math.max(spacerOriginalLeft, elementRect.right + gridSize);
                    }
                    if (spacerOriginalLeft === elementRect.left) {
                        newTop = Math.max(spacerOriginalTop, elementRect.bottom + gridSize);
                    }
                    
                    // Apply new position with smooth transition
                    spacer.style.transform = `translate(${newLeft - spacerOriginalLeft}px, ${newTop - spacerOriginalTop}px)`;
                }
            });
        }
    }

    // Apply resizing to all cards
    document.querySelectorAll('.kpi-card, .chart-container').forEach(makeResizable);
}

// Helper functions for resize overlay
function addResizeOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'resize-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 9999;
        cursor: se-resize;
    `;
    document.body.appendChild(overlay);
}

function removeResizeOverlay() {
    const overlay = document.querySelector('.resize-overlay');
    if (overlay) {
        overlay.remove();
    }
}

// Make the function globally available
window.initializeResizing = initializeResizing;

// Initialize everything when the document is ready
$(document).ready(function() {
    console.log('Document ready, loading KPIs and charts...');
    loadKPIs();
    loadCharts();
    initializeDragAndDrop();
    
    // Set up refresh interval
    setInterval(function() {
        loadKPIs();
        loadCharts();
    }, 300000); // Every 5 minutes
    
    // Initialize resizing functionality
    initializeResizing();
    
    // Load saved layout
    loadLayout();
});

// Make functions globally available
window.loadKPIs = loadKPIs;
window.loadCharts = loadCharts;
window.renderChart = renderChart;
window.toggleCustomizeMode = toggleCustomizeMode;
</script>
{% endblock %}

